[ { "title": "[Spring 기초] Object Mapper", "url": "/categories/backend/spring/object-mapper/", "categories": "Backend, Spring", "tags": "spring, object_mapper, jackson_object_mapper", "date": "2022-01-23 18:11:00 +0900", "snippet": "개요Java Object와 JSON의 형태를 자유롭게 변경하기 위해 사용되는 것이 Object Mapper이다. Serialize: Java Object → JSON Deserialize: JSON → Java Object형태를 바꿔주는 기능은 위의 두 가지 방식으로 나누어져 있으며 Object Mapper의 가장 중요한 기능이다.Jackson ObjectMapper가장 유명한 Object Mapper는 Jackson ObjectMapper이며 프로젝트 종속성에 추가시켜준 후 사용할 수 있다. Gradle 기준으로 설정하는 방법은 아래와 같다.dependencies { ... implementation &#39;com.fasterxml.jackson.core:jackson-databind:2.13.0&#39;}build.gradle의 dependencies에 다음과 같이 추가해주고 gradle을 업데이트 시켜주면 정상적으로 사용이 가능하다. 참고: 여기에서 jackson databind의 버전을 확인하고 원하는 버전을 implement 할 수 있다. 본 글에서는 게시 기준 가장 사용량이 많은 2.13.0 버전을 사용하도록 한다.기본 사용 예제public class Member { private int id; private String name; public Member(int id, String name) { this.id = id; this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; }}위와 같은 Java class가 있다고 가정하자. 이 Member class를 이용하여 어떻게 serialization, deserialization이 가능한 것인지 알아볼 것이다.Serialization (Java Object → JSON)JSON의 형태로 serialize 시킬 때 objectMapper의 writeValue() 와 writeValueAsString() 메소드를 사용한다. 이 두 메소드는 각각 파일로 변환, 문자열로 변환의 기능을 갖고 있다.import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import java.io.File;import java.io.IOException;public class ObjectMapperPractice { public static void main(String[] args) { ObjectMapper objectMapper = new ObjectMapper(); Member member = new Member(1, &quot;Sangyup&quot;); // Java Object -&amp;gt; JSON // 파일 출력: member.json try { objectMapper.writeValue(new File(&quot;원하는 경로/member.json&quot;), member); } catch (IOException e) { e.printStackTrace(); } // 문자열 출력 try { String memberAsJsonString = objectMapper.writeValueAsString(member); System.out.println(memberAsJsonString); } catch (JsonProcessingException e) { e.printStackTrace(); } // 출력값: {&quot;id&quot;:1,&quot;name&quot;:&quot;Sangyup&quot;} }}이 때, serialize 하려고 하는 class에 Getter가 없다면 안된다.Jackson 라이브러리는 serialize할 때, Getter의 prefix를 제거하고 소문자로 만들어서 식별하기 때문에 가져올 Getter가 없다면 오류를 내보내게 된다.{&quot;id&quot;:1,&quot;name&quot;:&quot;Sangyup&quot;}파일 출력의 결과로 위와 같이 member.json 이 생성되어 있음을 확인할 수 있다.Deserialization (JSON → Java Object)JSON을 Java Object로 deserialize시킬 때는 objectMapper의 readValue() 메소드를 이용한다.import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.core.JsonProcessingException;public class ObjectMapperPractice { public static void main(String[] args) { ObjectMapper objectMapper = new ObjectMapper(); // JSON -&amp;gt; Java Object String json = &quot;{\\&quot;id\\&quot;:2, \\&quot;name\\&quot;:\\&quot;Sangyup Lee\\&quot;}&quot;; try { Member newMember = objectMapper.readValue(json, Member.class); System.out.println(newMember); System.out.println(newMember.getId() + &quot; &quot; + newMember.getName()); } catch (JsonProcessingException e) { e.printStackTrace(); } }}이 때 아래와 같은 오류가 발생한다.Cannot construct instance of `ObjectMapperPractice.Member` (no Creators, like default constructor, exist): cannot deserialize from Object value (no delegate- or property-based Creator) at [Source: (String)&quot;{&quot;id&quot;:2, &quot;name&quot;:&quot;Sangyup Lee&quot;}&quot;; line: 1, column: 2]이러한 오류가 생기는 이유는 Member class에 기본 생성자가 없어서 그렇다.public class Member { public Member() { } ...}따라서 위와 같이 기본 생성자를 추가해주고 실행한다면 정상적으로 출력결과를 통해 Java Object가 생성되었음을 알 수 있다. 기본 생성자 이외에도 어노테이션 등을 사용해서 하는 방법이 있다. 예제에선 단순히 기본 생성자를 추가해서 사용하였지만 상황에 맞게 방법을 바꿔야 할 것이다. 다른 방법은 여기에서 확인할 수 있다.심화 사용 예제Configure를 통한 옵션 설정import com.fasterxml.jackson.databind.DeserializationFeature; JSON에는 존재하지만 대상 class에 field 값이 존재하지 않을 때String json = &quot;{\\&quot;id\\&quot;:2, \\&quot;name\\&quot;:\\&quot;Sangyup Lee\\&quot;, \\&quot;age\\&quot;:30}&quot;;objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);try { Member newMember = objectMapper.readValue(json, Member.class); System.out.println(newMember); System.out.println(newMember.getId() + &quot; &quot; + newMember.getName());} catch (JsonProcessingException e) { e.printStackTrace();}FAIL_ON_UNKNOWN_PROPERTIES 를 false로 작성하게 되면 class에 존재하지 않는 field는 무시된다. JSON에 null 값이 존재하고 이를 primitive type에 넘겨주어야 할 때objectMapper.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, false);FAIL_ON_NULL_FOR_PRIMITIVES 를 false로 작성하게 되면 null값이 무시되고 해당 primitive type의 기본값이 저장된다.Custom Serializer와 DeserializerJSON의 구조와 Java class의 구조가 다른 상황에서 serialize 혹은 deserialize 해야할 때 유용하다. Custom Serializerpublic class CustomCarSerializer extends StdSerializer&amp;lt;Car&amp;gt; { public CustomMemberSerializer() { this(null); } public CustomMemberSerializer(Class&amp;lt;Member&amp;gt; t) { super(t); } @Override public void serialize( Member member, JsonGenerator jsonGenerator, SerializerProvider serializer) { try { jsonGenerator.writeStartObject(); jsonGenerator.writeStringField(&quot;your_name_is&quot;, member.getName()); jsonGenerator.writeEndObject(); } catch (IOException e) { e.printStackTrace(); } }}SimpleModule module = new SimpleModule(&quot;CustomMemberSerializer&quot;, new Version(1, 0, 0, null, null, null));module.addSerializer(Member.class, new CustomMemberSerializer());objectMapper.registerModule(module);Member member = new Member(3, &quot;Smith&quot;);try { String memberAsJsonString = objectMapper.writeValueAsString(member); System.out.println(memberAsJsonString); // 출력결과: {&quot;your_name_is&quot;:&quot;Smith&quot;}} catch (JsonProcessingException e) { e.printStackTrace();} Custom Deserializerclass CustomMemberDeserializer extends StdDeserializer&amp;lt;Member&amp;gt; { public CustomMemberDeserializer() { this(null); } public CustomMemberDeserializer(Class&amp;lt;?&amp;gt; vc) { super(vc); } @Override public Member deserialize(JsonParser parser, DeserializationContext deserializer) { Member member = new Member(); ObjectCodec codec = parser.getCodec(); JsonNode node = null; try { node = codec.readTree(parser); } catch (IOException e) { e.printStackTrace(); } // 이름만을 빼내서 Object로 deserialize한다. JsonNode nameNode = node.get(&quot;name&quot;); try { // node.get의 return 값이 null일 수 있다. String name = nameNode.asText(); member.setName(name); } catch (NullPointerException e) { e.printStackTrace(); } return member; }}String json = &quot;{ \\&quot;id\\&quot; : 4, \\&quot;name\\&quot; : \\&quot;James\\&quot; }&quot;;SimpleModule module = new SimpleModule(&quot;CustomMemberDeserializer&quot;, new Version(1, 0, 0, null, null, null));module.addDeserializer(Member.class, new CustomMemberDeserializer());objectMapper.registerModule(module);try { Member member = objectMapper.readValue(json, Member.class); System.out.println(member.getName());} catch (JsonProcessingException e) { e.printStackTrace();}위의 두 가지 예제처럼 구조가 달라져도 custom하게 설정을 해줄 수 있다.Date Format 사용date format을 사용하여 JSON으로 serialize 해줄 수 있다.class MemberStatus { private int id; private Date registeredAt; ...}MemberStatus memberStatus = new MemberStatus();memberStatus.setId(1);memberStatus.setRegisteredAt(Date.from(Instant.now()));ObjectMapper objectMapper = new ObjectMapper();DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm a z&quot;);objectMapper.setDateFormat(df);try { String memberAsJsonString = objectMapper.writeValueAsString(memberStatus); // 출력결과: {&quot;id&quot;:1,&quot;registeredAt&quot;:&quot;2022-01-23 17:00 PM KST&quot;} System.out.println(memberAsJsonString);} catch (JsonProcessingException e) { e.printStackTrace();}Handling CollectionsJSON에 2개 이상의 데이터가 존재한다면 Collection의 형태로 deserialize 할 수 있다. As an ArrayString json = &quot;[{\\&quot;id\\&quot;:5, \\&quot;name\\&quot;:\\&quot;Tony\\&quot;}, {\\&quot;id\\&quot;:6, \\&quot;name\\&quot;:\\&quot;John\\&quot;}]&quot;;objectMapper.configure(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY, true);try { Member[] members = objectMapper.readValue(json, Member[].class);} catch (JsonProcessingException e) { e.printStackTrace();} As a ListString json = &quot;[{\\&quot;id\\&quot;:5, \\&quot;name\\&quot;:\\&quot;Tony\\&quot;}, {\\&quot;id\\&quot;:6, \\&quot;name\\&quot;:\\&quot;John\\&quot;}]&quot;;objectMapper.configure(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY, true);try { List&amp;lt;Member&amp;gt; memberList = objectMapper.readValue(json, new TypeReference&amp;lt;List&amp;lt;Member&amp;gt;&amp;gt;(){});} catch (JsonProcessingException e) { e.printStackTrace();}참고자료https://www.baeldung.com/jackson-object-mapper-tutorial" }, { "title": "[Spring 기초] 서블릿(servlet) 과 서블릿 컨테이너(servlet container)", "url": "/categories/backend/spring/servlet-and-servlet-container/", "categories": "Backend, Spring", "tags": "servlet, jsp, spring", "date": "2022-01-23 14:23:00 +0900", "snippet": "서블릿Dynmaic Web Page(동적 웹페이지)를 사용하기 위해 활용되는 기술로 클라이언트의 요청(request)을 처리하고 그 결과(response)를 반환하는 Servlet 클래스의 구현 규칙을 지킨 자바 웹 프로그래밍 기술이다. 서블릿이 없다면 개발자는 request와 response의 규약을 지키기 위해 상당히 많은 시간을 할애해야 할 것이며 코드 또한 굉장히 복잡해진다. 이 때, 서블릿이 이러한 request와 response를 간단한 메소드 호출만으로 가능하게 해주어, 개발자가 더욱 로직에만 집중할 수 있게끔 도와준다. 특징 Java의 쓰레드를 이용하여 동작 MVC 패턴의 컨트롤러로써 동작한다. http 프로토콜을 지원하는 javax.servlet.http.HttpServlet 클래스를 상속한다. html을 사용하여 응답하며 html 변경 시 servlet을 재컴파일 해야한다. init(), service(), destroy() 등의 메소드가 있다. 서블릿 컨테이너서블릿을 등록시켰다고 해서 서블릿이 자동으로 동작하는 것은 아니다. 서블릿을 관리하는 주체가 필요한데 그 역할을 해주는 것이 서블릿 컨테이너이다. 서블릿 컨테이너는 웹 서버와 소켓으로 통신하며 클라이언트의 요청을 받고 응답을 해준다. 서블릿 컨테이너의 대표적인 예가 톰캣(Tomcat)이다. 서블릿의 lifecycle을 관리 서블릿 컨테이너가 동작하면 서블릿 클래스를 인스턴스화하고 init() 함수를 호출한다. 이후 요청에 따라 적절한 메소드를 찾아서 호출하고 서블릿이 사라질 때에는 garbage collection을 통해 메모리에서 제거한다. 웹 서버와의 통신 지원 클라이언트의 Request를 받고 Response를 보내주기 위해 웹 서버와 소켓을 만들어 통신한다. listen, accept 등등을 API로 구현하여 개발자로 하여금 로직에만 신경 쓸 수 있게 해준다. 멀티 쓰레딩 관리 요청이 올 때마다 자바 쓰레드를 하나 생성하게 되는데 service 메소드 실행 후 자연스럽게 쓰레드를 삭제한다. 멀티 쓰레드의 관리를 해주기 때문에 쓰레드의 안정성을 신경쓰지 않아도 된다. 선언적인 보안 관리 보안 관리를 xml를 통해 진행하기 때문에 보안 쪽 설정이 변경되었다하더라도 소스코드를 고치고 재컴파일 할 필요가 없다. 서블릿 컨테이너에 의해 서블릿이 호출되고 사라지는데 클라이언트로부터 요청을 받으면 현재 실행할 서블릿이 그 전에 호출된 적이 있는지 판단하고 없다면 서블릿을 생성한다. 이 과정은 서블릿 별로 단 한 번만 동작하며 서블릿 컨테이너가 내려갈 때 해당 컨테이너가 관리하고 있던 서블릿은 사라지게 된다. 이를 싱글톤 형태라고 부른다. 한 번 생성된 서블릿은 이후 같은 요청에 대해 재사용된다.서블릿 사용방법서블릿 등록요청에 따라 적합한 서블릿을 찾을 수 있도록 서블릿을 등록해주어야 한다. 이것을 등록해주는 방법이 크게 2가지가 있는데 첫 번째는 web.xml 을 이용하는 방법, 두 번째가 @WebServlet 어노테이션을 이용하는 방법이다. 이전에는 web.xml 을 통해서만 서블릿을 관리할 수 있었지만 서블릿 3.0부터 어노테이션을 활용하여 서블릿을 매핑해줄 수 있게 되었다. web.xml 을 이용하는 방법&amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;hello&amp;lt;/servler-name&amp;gt; &amp;lt;servlet-class&amp;gt;Hello&amp;lt;/servlet-class&amp;gt;&amp;lt;/servlet&amp;gt;&amp;lt;Servlet-mapping&amp;gt; &amp;lt;servlet-name&amp;gt;hello&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;/hello&amp;lt;/url-pattern&amp;gt;&amp;lt;/Servlet-mapping&amp;gt;import javax.servlet.*;import javax.servlet.http.*;import java.io.*;public class Hello extends HttpServlet{ public void hello(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { ... }} @WebServlet 어노테이션을 이용하는 방법import javax.servlet.*;import javax.servlet.annotation.WebServlet;import javax.servlet.http.*;import java.io.*;@WebServlet(&quot;/hello&quot;)public class Hello extends HttpServlet { ...}HttpServletRequest http 프로토콜의 request 정보를 서블릿에게 전달하기 위해 사용되는 클래스 Header, Parameter, Cookie, URI, URL 등의 정보를 읽어오는 메소드를 가짐 Body의 Stream을 읽어들이는 메소드를 가짐HttpServletResponse 서블릿은 HttpServletResponse 객체에 Content type, 응답코드, 응답 메세지 등을 담아 전송서블릿 컨테이너 동작 방식 사용자가 http request를 보내면 이것이 서블릿 컨테이너로 전송된다. 해당 서블릿 컨테이너는 HttpServletRequest, HttpServletResponse 객체를 생성한다. web.xml 을 이용하여 해당 request가 어떤 서블릿에 대한 요청인지 확인 해당 서블릿에서 service 메소드를 호출하고 종류에 따라 doGet() , doPost() 등을 호출한다. 메소드는 동적 페이지 생성 후 HttpServletResponse 객체에 응답을 보낸다. 5번까지의 과정이 모두 끝나면 HttpServletRequest, HttpServletResponse 를 소멸시킨다. 참고: HttpServletRequest , HttpServletResponse 객체는 생성 후 소멸되지만 서블릿은 생성 후 소멸되지 않는 이유가 기본적으로 서블릿은 싱글톤으로 관리되기 때문이다.JSP(Java Server Pages)JSP는 Java 코드를 포함하고 있는 html 코드이다. 주의: 서블릿은 Java 코드 속에 html 코드를 포함하고 있다. (정반대)Java 코드 속 html 코드를 작성하기 굉장히 불편하기 때문에 이를 보완하기 위해 나온 ‘서버 스크립트 기술’이다. 스크립트 기술이란 실행 시점에 약속에 따라 매핑된 키워드로 변환되어 코드가 실행되는 것을 말한다.JSP는 &amp;lt;% %&amp;gt; 태그 안에 Java 코드를 작성한다. 화면(View)의 구현이 서블릿에 비해 굉장히 쉽기 때문에 MVC 패턴에서 View 부분의 코드를 JSP, Controller 부분을 서블릿으로 작성하여 JSP와 서블릿을 동시에 사용하는 형태를 차용하였다.MVC 구조에 대해서는 추후 포스팅에서 더 자세히 다루도록 하겠다.JSP 파일은 서블릿에 기반하고 있기 때문에 최종적으로는 서블릿으로 변환되어 실행된다. 이 과정은 한 번만 실행되기 때문에 요청이 많아져도 크게 성능이 떨어지지 않으며 JSP 파일에 변화가 있을 경우 그 때 다시 변환 과정을 거친다. 다만 이 과정은 WAS에 의해 알아서 처리되기 때문에 서블릿과 달리 재배포할 필요가 없다.종합하자면 JSP의 특징으로는 다음과 같다. 개발 속도가 빠르다. 배우기 쉽다. View 관련 작성이 용이하다. Java 코드를 &amp;lt;% %&amp;gt; 태그 안에 처리한다." }, { "title": "[C++] Mac에서 VSCode C++ PS 환경 세팅하기", "url": "/categories/ps/vscode-ps-setting/", "categories": "PS", "tags": "C++, VSCode", "date": "2021-12-30 23:07:00 +0900", "snippet": "진짜 오랜만에 다시 PS를 하려고 백준 온라인 저지 사이트를 키고 코드를 실행시킬 IDE를 열심히 찾았다. 실제 코딩에 들어가기 전 이런 세팅을 먼저 완벽히 끝내놓고 하는 타입이라 우선 나에게 맞는 환경을 찾아보기로 했다. Mac에서는 다음과 같은 IDE 옵션들이 있다. XCode Visual Studio CLion등등…솔직히 다 써봤지만 나한테 있어서 가장 큰 불만은 위의 IDE 들을 이용하게 된다면 하나의 프로젝트 단위로 관리해야 하며 프로젝트 생성에 의해 같이 생성되는 잡다한 파일, 폴더 등이 너무 많아진다는 점이다. 내가 쓰는 것은 오직 cpp 소스파일 하나 뿐인데 배보다 배꼽이 더 커지는 것이다. 그래서 결국 VSCode에다가 PS 환경 세팅을 하도록 했다. 물론 VSCode를 가장 자주 써서 제일 편한 것도 있다.빌드 세팅기본 환경g++ -vlldb -vMac에 가장 기본적으로 깔려 있는 컴파일 및 디버깅 관련 명령어 도구들이다. 제대로 깔려 있는지 버전 체크를 해본 후 만약 설치되어 있지 않다면 xcode-select --install 명령어를 통해 Xcode 명령어 도구를 설치한다.Microsoft C/C++ ExtensionVSCode에서 C/C++을 이용하고 싶다면 가장 필수적으로 깔아줘야 하는 설정이다.Code RunnerVSCode 상에서 설정해주어 명령어를 통한 컴파일이 가능하긴 하지만 Code Runner를 깔면 굉장히 간편하게 내가 작성한 Source Code를 빌드할 수 있다.필수적으로 해야되는 것은 아니지만 나는 터미널에서 작업하는 것이 훨씬 편하기 때문에 VSCode 설정을 열고 아래와 같은 설정을 체크해서 Output 패널 대신 Terminal에서 작업할 수 있게 해주었다.그리고 위의 버튼을 누르거나 혹은 직접 settings.json에 들어가서 아래와 같이 Executor Map 설정을 해준다.&quot;code-runner.executorMap&quot;: { &quot;cpp&quot;: &quot;cd $dir &amp;amp;&amp;amp; clang++ -std=c++17 $fileName -o $fileNameWithoutExt &amp;amp;&amp;amp; $dir$fileNameWithoutExt&quot;},-std=c++17 옵션을 통해 c++의 최신 문법을 사용할 수 있도록 해준다. 이것을 해주지 않는다면 최신 문법을 컴파일러가 읽지 못한다.내가 사용하고자 하는 폴더를 열어주고 Terminal-Configure Default Build Task… 를 눌러준다.그리고 위와 같이 clang++ 를 선택해준다.{ &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;type&quot;: &quot;cppbuild&quot;, &quot;label&quot;: &quot;C/C++: clang++ build active file&quot;, &quot;command&quot;: &quot;/usr/bin/clang++&quot;, &quot;args&quot;: [ &quot;-std=c++17&quot;, &quot;-fdiagnostics-color=always&quot;, &quot;-g&quot;, &quot;${file}&quot;, &quot;-o&quot;, &quot;${fileDirname}/${fileBasenameNoExtension}&quot; ], &quot;options&quot;: { &quot;cwd&quot;: &quot;${fileDirname}&quot; }, &quot;problemMatcher&quot;: [&quot;$gcc&quot;], &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true }, &quot;detail&quot;: &quot;compiler: /usr/bin/clang++&quot; } ]}그러면 위와 같이 tasks.json 이 생성되는데 &quot;args&quot; 의 첫 번째 아이템으로 “-std=c++17&quot;, 를 추가해주면 된다. 그러면 기본적으로 빌드 시 위의 tasks.json 에 적혀진 정보를 이용하게 된다. 여기까지 한다면 Code-runner를 통해 c++ 소스코드를 빌드하고 실행시킬 수 있다.나는 위와 같이 keyboard shortcut을 바꿔주어서 이용 중이다.디버그 세팅이후에는 디버깅 세팅을 완료할 차례이다.F5를 눌러 디버깅 설정을 시작하자. C++ (GDB/LLDB) 를 눌러준다.위의 두 개 중 아무거나 한 개를 눌러준다.{ &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;clang++ - Build and debug active file&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${fileDirname}/${fileBasenameNoExtension}&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;${fileDirname}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;lldb&quot;, &quot;preLaunchTask&quot;: &quot;C/C++: clang++ build active file&quot; } ]}그렇다면 위와 같이 launch.json 파일이 생성된다. 여기까지 왔으면 breakpoint를 설정해서 디버깅을 바로 진행 가능하다.❗️cin, cout 등이 안될 때launch.json 의 설정에서 &quot;externalConsole&quot; 의 설정을 false 에서 true 로 바꿔준다. 그러면 cin, cout 처럼 사용자와 상호작용을 하는 코드가 외부의 새로운 터미널에서 실행이 된다.LLDB 설치여기서부터는 선택사항이다 (M1 맥북의 경우 이 부분도 진행해주어야 한다고 들었지만 M1 맥북이 없는 관계로 테스트 할 수가 없다. 위까지 했는데 잘 안된다면 이 부분도 진행해보자). 나는 cin , cout 등을 새로운 터미널 창에서 해야된다는 사실이 굉장히 맘에 들지 않았다. 항상 내부 터미널로만 해결해왔기 때문에 이것을 해결하려고 계속 구글링해보았지만 도저히 찾을 수가 없어서 결국 새로운 확장프로그램을 설치하기로 했다.위의 확장 프로그램을 설치해주도록 한다. VSCode 상에서 LLDB를 이용할 수 있도록 해주는 확장 프로그램이다. 해당 확장 프로그램을 설치하고 launch.json 에서 &quot;type&quot;: &quot;cppdbg&quot; 에서 &quot;type&quot;: &quot;lldb&quot; 로 바꿔주면 끝이다.추가 설정 (깨끗한 폴더 유지)사실 이 글을 쓴 가장 큰 이유이기도 한데 나는 백준을 풀면서 문제 번호 별로 소스코드를 나눠서 저장하고 싶었다. 그래서 PS 폴더 내부에 문제_번호.cpp 로 이루어진 소스코드들로만 있었으면 좋겠다고 생각했다. 그렇기 때문에 위의 IDE들을 다 포기하고 이렇게 VSCode를 이용하여 PS 환경을 세팅한 것이다.(위의 문제 번호는 예시이다.)그런데 이렇게 해도 디버깅 관련 파일과 실행파일이 어쩔 수 없이 남게 된다. 그래서 해당 소스코드를 빌드하고 실행이 끝나거나 디버깅이 끝나면 해당 파일들을 다 없애주고 싶어서 추가적으로 설정해주려고 한다.rm -rf ./*.dSYMls -ar | grep -v &quot;\\.&quot; | xargs rm같은 폴더 내에 다음과 같은 쉘 스크립트 파일을 작성한다. 간단하게 설명하면 첫 번째 줄은 .dSYM 으로 끝나는 디버깅 관련 폴더들을 다 지우고 두 번째 줄은 확장자가 없는 executable 파일들을 지워준다. 그리고 해당 쉘 스크립트를 각 action이 끝났을 때마다 실행되도록 해주면 된다.{ &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ ..., { &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;clean&quot;, &quot;command&quot;: &quot;${fileDirname}/clean.sh&quot; } ]}{ &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;clang++ - Build and debug active file&quot;, &quot;type&quot;: &quot;lldb&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${fileDirname}/${fileBasenameNoExtension}&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;${fileDirname}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;lldb&quot;, &quot;preLaunchTask&quot;: &quot;C/C++: clang++ build active file&quot;, &quot;postDebugTask&quot;: &quot;clean&quot; // 이 부분 추가 } ]}tasks.json 에 build task 밑에 추가적으로 위와 같은 새로운 task를 만들어준다. 그리고 launch.json 에서 &quot;postDebugTask&quot;: &quot;clean&quot; 을 밑에 추가해줌으로써 Debuging이 끝나면 clean이라는 label을 가진 task가 실행될 수 있도록 한다. 그렇다면 자동적으로 해당 task에 의해 clean.sh 가 실행될 것이다. 여태까지 디버깅과 관련된 clean 작업이었고 이제 code-runner를 통해 디버깅 없이 실행만 시켰을 때 없애는 방법도 설정해보자.&quot;code-runner.executorMap&quot;: { &quot;cpp&quot;: &quot;cd $dir &amp;amp;&amp;amp; clang++ -std=c++17 $fileName -o $fileNameWithoutExt &amp;amp;&amp;amp; $dir$fileNameWithoutExt &amp;amp;&amp;amp; $dir/clean.sh&quot;},vscode의 settings.json에 들어가서 Executor Map 설정 끝에 위와 같이 &amp;amp;&amp;amp; $dir/clean.sh 를 붙여준다. &amp;amp;&amp;amp; 은 다중 명령어의 일종으로 &amp;amp;&amp;amp; 앞의 명령어가 정상적으로 실행 후 종료된 뒤 그 뒤의 명령어가 실행되도록 해준다. 그래서 실행이 끝나면 해당 디렉토리의 clean.sh 가 실행되는 것이다. 이것으로 모든 설정이 끝났고 vscode를 통해 PS를 하면서 이제 깨끗한 작업공간을 유지할 수 있다." } ]
